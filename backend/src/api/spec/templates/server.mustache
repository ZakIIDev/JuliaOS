{{>partial_header}}

@doc raw"""
Encapsulates generated server code for {{packageName}}

The following server methods must be implemented:

{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
- **{{operationId}}**
    - *invocation:* {{httpMethod}} {{{path}}}
    - *signature:* {{operationId}}(req::HTTP.Request{{#allParams}}{{#required}}, {{paramName}}::{{#isBinary}}Vector{UInt8}{{/isBinary}}{{^isBinary}}{{dataType}}{{/isBinary}}{{/required}}{{/allParams}};{{#allParams}}{{^required}} {{paramName}}=nothing,{{/required}}{{/allParams}}) -> {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}Nothing{{/returnType}}
{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
"""
module {{packageName}}


using JSON3
using HTTP
using URIs
using OpenAPI
using Oxygen
using OpenAPI.Servers
using Dates
using TimeZones
using Oxygen
using Oxygen.Reflection
using StructTypes
using Oxygen.Errors
import Oxygen: format_response!, handlerequest

const API_VERSION = "{{appVersion}}"
Oxygen.Core.oxygen_title="""
                                                                              -==                     --  ---  --        
  =@@@@@@@@@.                      -@@@= =@@@=                             -  -   @@#-                - #@@@@@@@@@@@# -     
         #@@#                      -@@@=  @@@                              @@@@-  --   -=#=-         =@@@@@@@###@@@@@@@=    
         #@@#                      -@@@=  -.-                       - ==   ###=- -      #@#-   -    =@@@@# -     - #@@@@@   
         #@@#                      -@@@=                            #@@@@   --  -@@@@=   -   -#@@   @@@@#-           @@#=   
         #@@# =##=-            =##= @@@=  =##       =#@@@@##         =#=  -=##=-  ===-  =#=- -=#=   @@@@#-           -      
         #@@# =@@#-            #@@# @@@=  #@@    #@@@@#==#@@@@#      - -   @@@@#   -   #@@@#        #@@@@#  -               
         #@@# =@@#-            #@@# @@@=  #@@   @@@=-       =@@@    #@@@#-  ==  -#@@#  -      ###=  -=@@@@@@@##===   -      
         #@@# =@@#-            #@@# @@@=  #@@  ###           #@@#   @@@@@     -  @@@@=    -   @@@-    - =#@@@@@@@@@@@@# -   
         #@@# =@@#-            #@@# @@@=  #@@         =======#@@#    ===--#@@@@= -    -#@@@#  -           -   ====#@@@@@@   
         #@@# =@@#-            #@@# @@@=  #@@   =#@@@@@@@@@@@@@@#  - =#=  #@@@@=- == --#@@@=     -                 - @@@@@  
         #@@# .@@#-           -#@@# @@@=  #@@  =@@@= -------- @@#  -=@@@=    - =@@@@@-      #@@@@   - =             =@@@@= 
         @@@   @@@=           =@@@# @@@=  #@@  @@@            @@#   -=@@#  ###=  #@@@=- ###= #@@=-  #@@@@=-          #@@@@  
      -#@@@     @@@=        -=@@@@# @@@=  #@@  #@@#-       -=@@@#     -=- @@@@@@ -     @@@@@=  --    #@@@@@#=     =#@@@@@=  
 - =#@@@@=.      #@@@#=   =#@@@@@@# @@@=  #@@  -#@@@#     -=@@@@@        -=@@@#  #@@#=- ### -          #@@@@@@@@@@@@@@@#    
 -@@@#=.            #@@@@@@@#  #@@= ##@=  #@@     =#@@@@@@@= #@#           ---  @@@@@@                  - ==########= -    $(API_VERSION) 
  --                  -----                          ----                        #@@#                                       
                                                                               --                                         
"""

{{=<% %>=}}
"""
Stores API interface specifications including HTTP metadata, function signature and return type
"""
struct APISpec
    http_method::String
    path::String
    handler::Function
    return_type::Type
end

"""
Global registry for API specifications
Structure: Dict{Symbol => Vector{APISpec}}
"""
const INTERFACE_SPECS = Dict{Symbol, Vector{APISpec}}()

"""
Macro for defining interface specifications
"""
macro interface(api_group, http_method, path, func_def)
    # Extract function name and return type
    func_expr = func_def.args[1]
    
    # Get function name and return type
    if func_expr.head == :(::)  # Function definition with return type
        call_expr = func_expr.args[1]
        func_name = call_expr.args[1]
        return_type = func_expr.args[2]
    else  # Function definition without return type
        func_name = func_expr.args[1]
        return_type = :Any  # Use Any as default return type
    end
    
    # Convert function definition to actual function
    func = eval(quote
        $(func_def)
    end)
    
    # Register interface specification
    quote
        if !haskey(INTERFACE_SPECS, $(esc(api_group)))
            INTERFACE_SPECS[$(esc(api_group))] = []
        end
        push!(INTERFACE_SPECS[$(esc(api_group))], 
              APISpec($http_method, $path, $func, $return_type))
        nothing
    end
end

"""
Global registry for generated handler functions
Structure: Dict{Symbol => Dict{Symbol => Dict{Symbol => Function}}}
- First level: API group name (e.g., :TestApi)
- Second level: Operation name (e.g., :test_hello)
- Third level: Handler function type (:read, :validate, :invoke)
"""
const GENERATED_HANDLERS = Dict{Symbol, Dict{Symbol, Dict{Symbol, Function}}}()


"""
Parameters:
- api_group::Symbol: API group name (e.g., :TestApi)
- operation_name::Symbol: Operation name (e.g., :test_hello)
- handler_type::Symbol: Handler function type (:read, :validate, :invoke)
- handler_func::Function: Handler function
"""
macro generated_handler(api_group, op_name, h_type, handler_func)
    # Convert function definition to actual function
    func = eval(quote
        $(handler_func)
    end)

    quote
        @assert $(esc(h_type)) in (:read, :validate, :invoke) "Handler type must be :read, :validate or :invoke"
        if !haskey(GENERATED_HANDLERS, $(esc(api_group)))
            GENERATED_HANDLERS[$(esc(api_group))] = Dict{Symbol, Dict{Symbol, Function}}()
        end
        if !haskey(GENERATED_HANDLERS[$(esc(api_group))], $(esc(op_name)))
            GENERATED_HANDLERS[$(esc(api_group))][$(esc(op_name))] = Dict{Symbol, Function}()
        end 
        GENERATED_HANDLERS[$(esc(api_group))][$(esc(op_name))][$(esc(h_type))] = $func
        nothing
    end
end

"""
Get all handler functions for a specific operation

Parameters:
- api_group::Symbol: API group name
- operation_name::Symbol: Operation name

Returns:
- NamedTuple: (read=Function, validate=Function, invoke=Function) or nothing
"""
function get_operation_handlers(api_group::Symbol, operation_name::Symbol)
    if !haskey(GENERATED_HANDLERS, api_group)
        @warn "API group not found: $api_group"
        return nothing
    end
    
    if !haskey(GENERATED_HANDLERS[api_group], operation_name)
        @warn "Operation not found: $api_group.$operation_name"
        return nothing
    end
    
    handlers = GENERATED_HANDLERS[api_group][operation_name]
    
    # Check if all required handler functions are present
    required_types = [:read, :validate, :invoke]
    for handler_type in required_types
        if !haskey(handlers, handler_type)
            @warn "Missing handler function: $api_group.$operation_name.$handler_type"
            return nothing
        end
    end
    
    return (
        read = handlers[:read],
        validate = handlers[:validate], 
        invoke = handlers[:invoke]
    )
end
<%={{ }}=%>

include("modelincludes.jl")
{{#apiInfo}}{{#apis}}
include("apis/api_{{classname}}.jl"){{/apis}}{{/apiInfo}}

"""
Register handlers for all APIs in this module in the supplied `Router` instance.

Paramerets:
- `router`: Router to register handlers in
- `impl`: module that implements the server methods

Optional parameters:
- `path_prefix`: prefix to be applied to all paths
- `optional_middlewares`: Register one or more optional middlewares to be applied to all requests.

Optional middlewares can be one or more of:
    - `init`: called before the request is processed
    - `pre_validation`: called after the request is parsed but before validation
    - `pre_invoke`: called after validation but before the handler is invoked
    - `post_invoke`: called after the handler is invoked but before the response is sent

The order in which middlewares are invoked are:
`init |> read |> pre_validation |> validate |> pre_invoke |> invoke |> post_invoke`
"""
function register(router::HTTP.Router, impl; path_prefix::String="", optional_middlewares...)
    {{#apiInfo}}
    {{#apis}}
    register{{classname}}(router, impl; path_prefix=path_prefix, optional_middlewares...)
    {{/apis}}
    {{/apiInfo}}
    return router
end

{{=<% %>=}}

"""
Automatically build OpenAPI middleware chain.

Arguments:
- api_group::Symbol: Name of the API group
- operation_name::Symbol: Name of the operation
- impl: Implementation object
- optional_middlewares...: Optional extra middlewares

Returns:
- Function: Composed middleware function
"""
function build_openapi_middleware(api_group::Symbol, operation_name::Symbol, impl; optional_middlewares...)
    handlers = get_operation_handlers(api_group, operation_name)
    
    if isnothing(handlers)
        error("Failed to build middleware chain: missing necessary handler for $api_group.$operation_name")
    end
    
    @info "ðŸ”§ Building middleware chain: $api_group.$operation_name"
    @info "   - Read function: $(nameof(handlers.read))"
    @info "   - Validate function: $(nameof(handlers.validate))"
    @info "   - Invoke function: $(nameof(handlers.invoke))"
    
    # Build the middleware chain using OpenAPI.Servers.middleware
    return OpenAPI.Servers.middleware(
        impl, 
        handlers.read, 
        handlers.validate, 
        handlers.invoke; 
        optional_middlewares...
    )
end


"""
Check whether two types are compatible.
"""
function is_type_compatible(required_type::Type, actual_type::Type)
    # If required type is Any, all types are compatible
    required_type === Any && return true
    
    # If actual type is a subtype of required type, it's compatible
    actual_type <: required_type && return true
    
    return false
end

"""
Stores the result of function implementation check.
"""
struct ImplementationCheckResult
    success::Bool                     # Whether the check passed
    matching_spec::Union{APISpec, Nothing}  # Matched spec
    error_message::Union{String, Nothing}   # Error message (if any)
    impl_func::Function              # Implementation function
    impl_return_type::Type           # Return type of implementation
end

"""
Check whether a single function implementation conforms to spec.

Returns:
- ImplementationCheckResult: Detailed check result
"""
function check_single_implementation(api_group::Symbol, impl_func::Function, impl_return_type::Type)
    if !haskey(INTERFACE_SPECS, api_group)
        return ImplementationCheckResult(
            false,
            nothing,
            "No API spec found for group $api_group",
            impl_func,
            impl_return_type
        )
    end
    
    specs = INTERFACE_SPECS[api_group]
    matching_spec = nothing
    
    # Find matching spec
    for spec in specs
        if nameof(spec.handler) == nameof(impl_func)
            matching_spec = spec
            break
        end
    end
    
    if isnothing(matching_spec)
        return ImplementationCheckResult(
            false,
            nothing,
            "No API spec definition found for function $(nameof(impl_func))",
            impl_func,
            impl_return_type
        )
    end
    
    # Validate parameters
    @info "ðŸ” Validating parameters..."
    spec_func_details = Oxygen.Core.parse_func_params(matching_spec.path, matching_spec.handler)
    handler_func_details = Oxygen.Core.parse_func_params(matching_spec.path, impl_func)
    
    # Only check basic structure
    if handler_func_details.info.name != spec_func_details.info.name
        return ImplementationCheckResult(
            false,
            matching_spec,
            "Function name mismatch",
            impl_func,
            impl_return_type
        )
    end
    
    if length(handler_func_details.info.sig) != length(spec_func_details.info.sig)
        return ImplementationCheckResult(
            false,
            matching_spec,
            "Parameter count mismatch",
            impl_func,
            impl_return_type
        )
    end
    
    # Check return type
    spec_return_type = matching_spec.return_type
    if !is_type_compatible(spec_return_type, impl_return_type)
        return ImplementationCheckResult(
            false,
            matching_spec,
            "Incompatible return type: expected $(spec_return_type), got $(impl_return_type)",
            impl_func,
            impl_return_type
        )
    end

    return ImplementationCheckResult(
        true,
        matching_spec,
        nothing,
        impl_func,
        impl_return_type
    )
end

"""
Parse function definition and extract name and return type.

Arguments:
- func_def: Function definition expression

Returns:
- (func_name, return_type): Tuple containing function name and return type
"""
function parse_function_definition(func_def)
    func_expr = func_def.args[1]
    
    # Extract function name and return type
    if func_expr.head == :(::)  # Function with return type annotation
        call_expr = func_expr.args[1]
        func_name = call_expr.args[1]
        return_type = func_expr.args[2]
    else  # Function without return type
        func_name = func_expr.args[1]
        return_type = :Any  # Default to Any
    end
    
    return func_name, return_type
end

"""
Parse registration configuration parameters.
"""
function parse_register_config(config)
    default_config = (
        prefix = "",
        tags = String[],
        middleware = Function[],
        interval = nothing,
        cron = nothing
    )
    
    if config isa String || config isa Symbol
        return merge(default_config, (prefix = config,))
    elseif Meta.isexpr(config, :tuple)
        return merge(
            default_config,
            (
                prefix = config.args[1],
                tags = length(config.args) > 1 ? config.args[2] : String[],
                middleware = length(config.args) > 2 ? config.args[3] : Function[],
                interval = length(config.args) > 3 ? config.args[4] : nothing,
                cron = length(config.args) > 4 ? config.args[5] : nothing
            )
        )
    else
        error("Invalid config parameter format")
    end
end

"""
Serialize handler with error formatting and HTTP response wrapping.
"""
function serializer_handler(handler)
    function serializer_with_http_response_handler(req::HTTP.Request)
        return handlerequest(true; show_errors=true) do
            try
                format_response!(req, handler(req))  # Format and save response
                return req.response
            catch e
                if isa(e, OpenAPI.ValidationException)
                    return HTTP.Response(422,
                        ["Content-Type" => "application/json"],
                        body=JSON3.write(Dict(
                            "error" => "Unprocessable Entity",
                            "message" => e.reason,
                            "details" => Dict(
                                "loc" => e.parameter,
                                "msg" => e.reason,
                                "type" => e.rule,
                                "input" => e.value
                            )
                        ))
                    )
                elseif isa(e, Oxygen.Errors.ValidationError)
                    return HTTP.Response(422,
                        ["Content-Type" => "application/json"],
                        body=JSON3.write(Dict(
                            "error" => "Unprocessable Entity",
                            "message" => e.msg,
                            "details" => e.cause
                        ))
                    )
                end
                rethrow(e)
            end
        end
    end
end

"""
Register API handler to routing system

Parameters:
- api_group::Symbol: API group name
- func::Function: handler function
- return_type::Type: return type of the function
- prefix::String: API path prefix

Returns:
- Bool: whether registration was successful
"""
function register_api_route(
    api_group::Symbol, 
    func,
    return_type::Type;
    prefix::String="",
    tags::Vector{String}=Vector{String}(),
    middleware::Union{Vector, Nothing}=nothing,
    interval::Union{Real, Nothing}=nothing,
    cron::Union{String, Nothing}=nothing
    )
    @info "ðŸš€ Starting API route registration: $api_group.$(nameof(func))"

    # Ensure prefix format is correct
    prefix = normalize_path_prefix(prefix)
    
    # Ensure API group exists
    if !haskey(INTERFACE_SPECS, api_group)
        @error "âŒ API group $api_group not found in interface specification"
        error("API group $api_group not defined")
        return false
    end

    # Check implementation
    result = check_single_implementation(api_group, func, return_type)
    if !result.success
        @error "âŒ Implementation check failed: $(result.error_message)"
        error("Function $(string(nameof(func))) does not conform to spec: $(result.error_message)")
        return false
    end
    @info "âœ… Function $(string(nameof(func))) passed implementation check"

    # Register route
    if !isnothing(result.matching_spec)
        route = prefix * result.matching_spec.path
        httpmethod = result.matching_spec.http_method
        operation_name = nameof(result.matching_spec.handler)
        @info "ðŸŒ Registering route: $httpmethod $route"
        try

            actual_middleware = isnothing(middleware) ? Function[] : middleware
            # TODO
            # openapi_middleware = build_openapi_middleware(api_group, operation_name, func; actual_middleware...)
            parsed_route = Oxygen.Core.parse_route(httpmethod, route)
            func_details = Oxygen.Core.parse_func_params(route, func)
            
            # Generate OpenAPI documentation (if enabled)
            if Oxygen.CONTEXT[].docs.enabled[]
                generate_openapi_docs(parsed_route, httpmethod, func_details, return_type)
            end
            
            # Register handler
            Oxygen.Core.registerhandler(
                Oxygen.CONTEXT[], 
                Oxygen.CONTEXT[].service.router, 
                httpmethod, 
                parsed_route, 
                func, #TODO
                func_details
            )
            
            @info "âœ¨ Route registered successfully: $httpmethod $route"
            return true
        catch e
            @error "âŒ Route registration failed" exception=(e, catch_backtrace())
            return false
        end
    end
    return false
end

"""
Normalize path prefix
"""
function normalize_path_prefix(prefix::String)
    # Ensure prefix starts with a slash
    if !startswith(prefix, "/")
        prefix = "/" * prefix
    end
    
    # Ensure prefix does not end with a slash
    if endswith(prefix, "/")
        prefix = prefix[1:end-1]
    end
    
    return prefix
end

"""
Generate OpenAPI documentation
"""
function generate_openapi_docs(route, httpmethod, func_details, return_type)
    try
        queryparams = func_details.queryparams
        pathparams = func_details.pathparams
        headers = func_details.headers
        bodyparams = func_details.bodyargs
        
        @info "ðŸ“š Generating OpenAPI docs: $route"
        
        Oxygen.Core.registerschema(
            Oxygen.CONTEXT[].docs, 
            route, 
            httpmethod, 
            pathparams, 
            queryparams, 
            headers, 
            bodyparams, 
            Vector([return_type])
        )
    catch error
        @warn "Failed to generate OpenAPI docs: $route - $error"
    end
end

# Define forced parameters (not user-overridable)
const FORCED_PARAMS = Dict(
    :serialize => false,  # Force disable default serializer since we use custom serializer_handler
)

"""
    serve([ctx::ServerContext];
        middleware::Vector=[],
        host::String="127.0.0.1",
        port::Int=8080;
        kwargs...)

Wrapper for Oxygen.serve to ensure correct middleware order and serialization handling.

Parameters:
- ctx: optional ServerContext
- middleware: user-defined middleware list
- host: server host
- port: server port
- kwargs: additional parameters passed to Oxygen.serve

Config options:
- async::Bool=false: run server asynchronously
- parallel::Bool=false: process requests in parallel
- catch_errors::Bool=true: catch errors
- show_errors::Bool=true: show error details
- docs::Bool=true: enable API documentation
- metrics::Bool=true: enable metrics collection
- show_banner::Bool=true: show startup banner
- docs_path::String="/docs": API docs path
- schema_path::String="/schema": OpenAPI schema path
- external_url::Union{String,Nothing}=nothing: external access URL

Returns:
- Oxygen.Server instance
"""
function serve(;
    host::String="127.0.0.1",
    port::Int=8080,
    middleware::Vector=[],
    kwargs...)
    async = Base.get(kwargs, :async, false)

    try
        # Ensure serializer_handler is always at the end of middleware chain
        final_middleware = if isempty(middleware)
            [serializer_handler]
        else
            [middleware..., serializer_handler]
        end
        merged_params = merge(FORCED_PARAMS, Dict(kwargs))
        return Oxygen.Core.serve(
                Oxygen.CONTEXT[];
                middleware=final_middleware,
                host=host,
                port=port,
                merged_params...)
    finally
        # Close server on exit if not running asynchronously
        if !async 
            terminate()
            # Only reset state on exit if running interactively
            isinteractive() && resetstate()
        end
    end
end
<%={{ }}=%>


{{#exportModels}}
# export models
{{#models}}{{#model}}export {{classname}}
{{/model}}{{/models}}
{{/exportModels}}
export @interface,@generated_handler,serve
end # module {{packageName}}
